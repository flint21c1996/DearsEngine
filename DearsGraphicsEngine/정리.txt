+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=aiAnimation=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=

아래의 코드는 assimp 라이브러리의 aiAnimation 구조체에 대한 정리이다.
// ---------------------------------------------------------------------------
/*
애니메이션은 여러 노드에 대한 키 프레임 데이터로 구성된다. 
이 구조체는 애니메이션의 영향을 받는 각 노드에 대한 별도의 데이터들을 제공한다.
*/
struct aiAnimation {
    /*------------------------------------------------------------------------------------------------
    애니메이션의 이름이다. 이 데이터를 export한 모델링 패키지가 단일 애니메이션 채널만 지원하는 경우 이 이름은 일반적으로 비어있다. 
    */
    C_STRUCT aiString mName;

    /*------------------------------------------------------------------------------------------------
    애니메이션의 지속 시간(틱)    
    */
    double mDuration;

    /*------------------------------------------------------------------------------------------------
    초당 틱, 가져온 파일에 지정되지 않은 경우 -> 0
    */
    double mTicksPerSecond;

    /*------------------------------------------------------------------------------------------------
    본 애니메이션 채널수 , 각 채널은 단일 노드에 영향을 준다.
    */
    unsigned int mNumChannels;

    /*------------------------------------------------------------------------------------------------
    노드 애니메이션 채널 수, 각 채널은 단일 노드에 영향을 준다. 배열의 크기는 mNumChannels이다.
    */
    C_STRUCT aiNodeAnim **mChannels;

    /*------------------------------------------------------------------------------------------------
    메시 애니메이션 채널 수, 각 채널은 단일 메시 하나에 영향을 미치며, 버택스 기반 애니메이션을 정의한다.
    */
    unsigned int mNumMeshChannels;

    /*------------------------------------------------------------------------------------------------
    메시 애니에미션 채널, 각 채널은 단일 메시하나에 영향을 준다.
    배열의 크기는 mNumMeshChannels이다.
    */
    C_STRUCT aiMeshAnim **mMeshChannels;

    /*------------------------------------------------------------------------------------------------
    매시 애니메이션 채널 수, 각 채널은 단일 메시 하나에 영향을 미치며, 모핑 애니메이션을 정의한다.
    */
    unsigned int mNumMorphMeshChannels;

    /*------------------------------------------------------------------------------------------------
    모프 메시 애니메이션 채널, 각 채널은 단일 메시 하나에 영향을 준다. 배열의 크기는 mNumMorphMeshChannels이다.
    */
    C_STRUCT aiMeshMorphAnim **mMorphMeshChannels;

+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=aiNodeAnim=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=
      
아래의 코드는 assimp 라이브러리의 aiNodeAnim 구조체에 대한 정리이다.
struct aiNodeAnim {
    /*------------------------------------------------------------------------------------------------
    이 애니메이션의 영향을 받는 노드의 이름, 노드가 존재해야하며, 고유해야한다.
    */
    C_STRUCT aiString mNodeName;

    /*------------------------------------------------------------------------------------------------
    위치 키의 개수
    */
    unsigned int mNumPositionKeys;

    /*------------------------------------------------------------------------------------------------
    이 애니메이션 채널의 위치 키, 위치는 3D 벡터값으로 저장이 되며, 배열의 크기는 mNumPositionKey이다.
    위치키가 있는 경우 적어도, 하나 이상의 회전키와, 스케일링 키가 있다.
    */
    C_STRUCT aiVectorKey *mPositionKeys;

    /*------------------------------------------------------------------------------------------------
    회전 키의 개수
    */
    unsigned int mNumRotationKeys;

    /*------------------------------------------------------------------------------------------------
    이 애니메이션 채널의 회전 키, 회전키는 4D벡터인 쿼터니언으로 저장된다. 배열의 크기는 mNumRotationKeys 이다.
    회전 키가 있는 경우, 적어도 하나 이상의 위치 키와, 스케일링 키가 하나 이상 있다.
    */
    C_STRUCT aiQuatKey *mRotationKeys;

    /*------------------------------------------------------------------------------------------------
    스케일링 키의 개수
    */
    unsigned int mNumScalingKeys;

    /*------------------------------------------------------------------------------------------------
    애니메이션 태널의 스케일링 키, 스케일링은 3D벡터로 지정된다. 배열의 크기는 mNumScalingKeys이다.
    스케일링 키가 있는 경우, 적어도 하나 이상의 위치 키와, 스케일링 키가 하나 이상 있다.
     */
    C_STRUCT aiVectorKey *mScalingKeys;

    /*------------------------------------------------------------------------------------------------
    첫 번째 키가 발생하기 전에 애니메이션이 어떻게 동작하는지 정의한다.
    기본 값은 aiAnimbehaviour_DEFAULT(영향을 받는 애니메이션의 원래 변환행렬이 사용됨)이다.
     */
    C_ENUM aiAnimBehaviour mPreState;

    /*------------------------------------------------------------------------------------------------
    마지막 키가 처리된 후 애니메이션의 동작 방식을 정의한다.
    기본값은 aiAnimBehaviur_DEFAULT(영향을 받는 애니메이션의 원래 변환행렬을 사용한다)이다.
     */
    C_ENUM aiAnimBehaviour mPostState;

+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+aiScene+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=

아래의 코드는 assimp 라이브러리의 aiScene구조체에 대한 정리이다.
struct aiScene 
 {
    /*------------------------------------------------------------------------------------------------
    aiScene의 mFlags 필드는 씬의 상택나 특성을 나타내는 플래그를 설정하기 위해 사용된다.
    기본값은 0이며, AI_SCENE_FLAGS_INCOMPLETE 과 같은 특정 플래그를 검사하여 씬이 완전히 로드되었는지 확인할 수 있다.
    씬 로딩과정에서 발생할 수 있는 여러가지 문제를 식별하고 대응하기 위해 이러한 플래그를 활용하는 것이 중요하다.
     */
    unsigned int mFlags;

    /*------------------------------------------------------------------------------------------------
    계층 구조의 루트노드.
    모델을 가져오는데 성공하였고, 측별한 플래그가 설정되지 않은 경우에는 퇴소한 하나의 루트노드가 있다.
    추가 노드의 존재여부는 가져온 파일의 형식과 콘텐츠에 따라 달라진다.
    */
    C_STRUCT aiNode* mRootNode;

    /*------------------------------------------------------------------------------------------------
     씬이 가지고 있는 메시의 수
    */
    unsigned int mNumMeshes;

    /*------------------------------------------------------------------------------------------------
    메시배열.
    이 배열에 엑세스 하려면 aiNode구조에 주어진 인덱스를 사용한다. 배열의 크기는 mNumMeshes이다.
    AI_SCENE_FLAGS_INCOMPLETE가 설정되지 않은 경우 항상 머터리얼이 하나 이상 있다.
    */
    C_STRUCT aiMesh** mMeshes;

    /*------------------------------------------------------------------------------------------------
    씬이 가지고 있는 머테리얼의 수
    */
    unsigned int mNumMaterials;

    /*------------------------------------------------------------------------------------------------
    머테리얼의 배열

    이 배열에 엑세스 하려면 각 aiMesh 구조에 주어진 인덱스를 사용한다. 배열의 크기는 mNumMaterials이다.
    만약 AI_SCENE_FLAGS_INCOMPLETE 플래그가 설정되어 있지 않으면 항상 머티리얼이 하나 이상 존재한다.
    */
    C_STRUCT aiMaterial** mMaterials;

    /*------------------------------------------------------------------------------------------------
    씬이 가지고 있는 애니메이션의 수. 
    */
    unsigned int mNumAnimations;

    /*------------------------------------------------------------------------------------------------
    애니메이션 배열
    지정된 파일에서 가져온 모든 애니메이션이 여기에 나열된다. 배열의 크기는 mNumAnimations이다.
    */
    C_STRUCT aiAnimation** mAnimations;

    /*------------------------------------------------------------------------------------------------
    파일에 포함된 텍스쳐의 개수
    */
    unsigned int mNumTextures;

    /* ------------------------------------------------------------------------------------------------
    임베디드 텍스쳐 배열.
    텍스쳐를 파일에 임베드하는 파일 포맷은 많지 않다.
    파일접근이 최소화되고 오버헤드가 감소하나, 재사용성이 떨어지고 메모리의 사용이 증가할 수 있다. 
    */
    C_STRUCT aiTexture** mTextures;

    /*------------------------------------------------------------------------------------------------
    씬이 가지고 있는 광원 수, 광원은 완전히 선택사항이며, 대부분의 경우 0이다.
    */
    unsigned int mNumLights;

    /*------------------------------------------------------------------------------------------------
    광원 배열.
    지정된 파일에서 임포트한 모든 광원은 여기에 나열된다. 배열의 크기는 mNumLight이다.
    */
    C_STRUCT aiLight** mLights;

    /*------------------------------------------------------------------------------------------------
    씬에 존재하는 카메라의 수, 카메라는 완전히 선택 사항이며, 대부분 0이다.
    */
    unsigned int mNumCameras;

    /*------------------------------------------------------------------------------------------------
    카메라 배열.
    지정된 파일에서 가져온 모든 카메라가 여기에 나열된다. 배열의 크기는 mNumCameras이다. 배열의 첫 번째 카메라가 씬의 기본 카메라가 된다.(존재 시)
    */
    C_STRUCT aiCamera** mCameras;

    /*------------------------------------------------------------------------------------------------
    씬 자체에 할당된 글로벌 메타데이터.
    이 데이터는 단위 변환, 버전, 공급업체 또는 기타 모델별 데이터와 같이 씬에 속한 글로벌 메타데이터가 포함된다.
    포맷별 메타데이터를 저장하는데도 사용될 수 있다.
    */
    C_STRUCT aiMetadata* mMetaData;

    /*------------------------------------------------------------------------------------------------
    씬 자체의 이름
    */
    C_STRUCT aiString mName;

+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+aiMesh=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=

struct aiMesh 
{
    /*------------------------------------------------------------------------------------------------
    aiPrimitiveType 열거형 멤버의 비트 단위 조합
    메시에 어떤 유형의 프리미티브가 있는지 지정
    */
    unsigned int mPrimitiveTypes;

    /*------------------------------------------------------------------------------------------------
    이 메시의 버텍스 수.
    모든 버텍스별 데이터 배열의 크기이기도 하다.
    이 멤버의 최대값은 AI_MAX_VERTTICES이다.
    */
    unsigned int mNumVertices;

    /*------------------------------------------------------------------------------------------------
    이 메시의 프리미티브(삼각형, 폴리곤, 선)의 수.
    mFaces 배열의 크기이기도 하다. 이 멤버의 최대값은 #AI_MAX_FACES이다.
    */
    unsigned int mNumFaces;

    /*------------------------------------------------------------------------------------------------
    버텍스 위치.
    이 배열은 항상 메시 안에 존재한다. 배열의 크기는 mNumVertices이다.
    */
    C_STRUCT aiVector3D *mVertices;

    /*------------------------------------------------------------------------------------------------
    버텍스의 노말
    C_STRUCT aiVector3D *mNormals;
    내부의 벡터는 정규화된 벡터이다.(normalize)
    배열의 크기는 mNumVertices이다.
    */
    C_STRUCT aiVector3D *mNormals;
    
    /*------------------------------------------------------------------------------------------------
    버텍스는 양의 X텍스쳐 축 방향을 가리키며, 배열은 정규화된 벡터를 포함하며, 없는 경우 nullptr이다.
    배열의 크기는 mNumVertices이다. 점과 선으로만 구성된 메시에는 정규 벡터가 없을 수도 있다. 혼합프리미티브 유형(예. 점과 삼각형)이
    있는 메시에는 노멀이 있을 수 이지만 점 또는 선 프리미티브에서만 참조되는 점점에 대한 노멀은 정의되지 않으며 qNaN으로 설정된다.
    */
    C_STRUCT aiVector3D *mTangents;

    /*------------------------------------------------------------------------------------------------
    버텍스의 바이탄젠트는 양의 Y텍스쳐 축의 방향을 가리킨다. 배열에는 정규화된 벡터가 포함되며, 없는 경우 nullptr이다.
    배열의 크기는 mNumVertices이다.
    바이탄젠트(BiTangent) : 메시가 탄젠트를 포함한다면, 자동으로 바이탄젠트 정보도 포함한다는 것을 의미한다. 바이탄젠트는 탄젠트와
    노멀 벡터에 모두 수직인 벡터로, 텍스쳐의 양의 Y축 방향을 나타낸다.
    */
     C_STRUCT aiVector3D *mBitangents;

    /*------------------------------------------------------------------------------------------------
    버텍스당 색상, 없는 경우 nullptr, 각 배열은 크키가 mNumVertices이다.
    메시에는 0에서 AI_MAX_NUMBER_OF_COLOR_SETS 버텍스 까지 포함될 수 있다.
    */
     C_STRUCT aiColor4D *mColors[AI_MAX_NUMBER_OF_COLOR_SETS];

    /*------------------------------------------------------------------------------------------------
    주어진 UVW 채널의 컴포넌트 수를 지정한다.
    UVW채널 : 최대 3개의 채널(UVW)을 지원하며, 이는 3D 텍스쳐 매핑이나 큐브맵 접근에 사용될 수 있다.
    ex. 값이 2이면 U,V만 사용되고 W는 0.0f로 세팅된다. - 2D 텍스쳐 매핑에 적합.
    */
    unsigned int mNumUVComponents[AI_MAX_NUMBER_OF_TEXTURECOORDS];

    /*------------------------------------------------------------------------------------------------
    메시가 구성되는 면, 각 면은 인덱스에 의해 자수의 정점을 나타낸다.
    이 배열은 메시에서 항상 존재하며 크기는 mNumFace로 지정된다.
    AI_SCENE_FLAGS_NON_VERBOSE_FORMAT이 설정되지 않은 경우, 각 면은 고유한 정점 집합을 참조한다.
    */
    C_STRUCT aiFace *mFaces;

    /*------------------------------------------------------------------------------------------------
     이 메시가 포함하는 본의 수, 0일 수도 있으며, 이 경우 mBones 배열은 nullptr이다.
    */
    unsigned int mNumBones;

    /*------------------------------------------------------------------------------------------------
    본은 프레임 계층구조에서 찾을 수 있는 이름과 프레임 계층구조와 버텍스 가중치 세트로 구성된다.
    */
    C_STRUCT aiBone **mBones;
    
    /*------------------------------------------------------------------------------------------------
    이 메시가 사용하는 머테리얼
    메시는 하나의 머테리얼만 사용한다. 임포트한 모델이 여러 머테리얼을 사용하는 경우, 임포트틑 메시를 분할한다.
    이 값을 씬 머테리얼 배열에 인덱스로 사용한다.
    */
    unsigned int mMaterialIndex;

    /*------------------------------------------------------------------------------------------------
    메시의 이름. 필수사항은 아님.
    */
    C_STRUCT aiString mName;


    /*------------------------------------------------------------------------------------------------
    aiAnimMesh 구조체와 mAnimMeshes 배열은 Assimp라이브러리에서 메시에 대한 버텍스 기반 애니메이션 데이터를
    처리하는 방법. 여기서 "버텍스 기반 애니메이션"이란 모델의 각 버텍스의 위치나 노멀 등의 속성이 시간에 따라
    변화하는 애니메이션을 의미한다. 이는 본 기반의 스키닝 애니메이션과는 다른 접근 방식이다.
    */
    C_STRUCT aiAnimMesh **mAnimMeshes;
    
    /*------------------------------------------------------------------------------------------------
    Method of morphing when anim-meshes are specified.
    애니메이션 메시가 지정됭 때 사용되는 형태 변형 방식을 나타내는 열거형 변수
    */
    enum aiMorphingMethod mMethod;

    
    /*------------------------------------------------------------------------------------------------
    바운딩 박스
    */
    C_STRUCT aiAABB mAABB;

    
    /*------------------------------------------------------------------------------------------------
    버텍스 UV 스트림 이름, AI_MAX_NUMBER_OF_TEXTURECOORDS 크기의 배열에 대한 포인터
    */
    C_STRUCT aiString **mTextureCoordsNames;
}

+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=aiBone+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=

/*
요약 : 메시의 단일 뼈대
뼈에는 프레임 계층 구조에서 찾을 수 있고, 애니메이션 주소를 지정할 수 있는 이름이 있다.
(모든 본은 하나의 노드로 생각할수 있고 그 노드는 계층구조를 띌 수 있기 때문이다.)
또한 버택스에 여러 영향을 미치며, 메시 위치와 바인딩 시점의 뼈 위치를 연결하는 행렬이 있다.
*/
struct aiBone {
    /*------------------------------------------------------------------------------------------------
    본의 이름
    */
    C_STRUCT aiString mName;

    /*------------------------------------------------------------------------------------------------
     이 본의 영향을 받는 버텍스 수.
     이 멤버의 최댓값은 AI_MAX_BONE_WEIGHTS이다. 
     ***이 숫자는 mWeights 배열의 크기와 같습니다.
     */
    unsigned int mNumWeights;

    // 만약 ASSIMP_BUILD_NO_ARMATUREPOPULATE_PROCESS가 정의되어 있지 않다면의 조건
    // 여기서 ASSIMP_BUILD_NO_ARMATUREPOPULATE_PROCESS 는 Assimp 라이브러리의 컴파일 옵션 중 하나이다.
    //이 매크로가 정의되어 있다면 라이브러리는 'Armature Populate(아마추어 팝업레이트)' 처리 과정을 포함시키지 않는다.
    //즉, 이 처리과정은 뼈대(스켈레톤) 정보를 보다 구체적으로 처리하고, 모델의 뼈대와 관련된 추가 데이터를 채우는 과정을 말한다.

------------------------------------------------------------------------------------------------------------------------------------

#ifndef ASSIMP_BUILD_NO_ARMATUREPOPULATE_PROCESS
    /*------------------------------------------------------------------------------------------------
   The bone armature Node 스켈레톤 변환에 사용된다.
   mArmature 변수는 특정 본(bone)이 속한 전체 스켈레톤(뼈대) 구조 중에서, 그 스켈레톤의 "루트" 또는 "기본" 노드를 가리킴
     */
    C_STRUCT aiNode *mArmature;

    /*------------------------------------------------------------------------------------------------
    mArmature는 본이 포함된 스켈레톤 구조의 루트 노드를,
    mNode는 본 자체를 씬 내에서 나타내는 특정 노드를 각각 참조
    따라서 mNode는 해당 본을 표현하는 구체적인 노드를 가리키며, 이 노드를 통해 본의 위치, 회전, 스케일 등의 변형 정보에 접근할 수 있다
     */
    C_STRUCT aiNode *mNode;

#endif
    /*------------------------------------------------------------------------------------------------
     버텍스 인덱스에 따른 이 본의 영향력 가중치
     가중치 값은 0에서 1 사이이며, 0은 본이 전혀 영향을 미치지 않음을, 1은 본이 버텍스 위치 결정에 완전히 기여.
     mWeights 배열은 본이 메시의 어떤부분에 영향을 미치는지, 그리고 그 영향의 정도가 어느 정도인지에 대한 상세 정보를
     제공한다. 이 정보는 본 기반 애니메이션과 스키닝 과정에 매우 중요한데, 본의 움직임이 메시의 실제 형태 변화로 
     어떨게 전달되는지 결정하기 때문이다.

     크기는 mNumWeights이다.
     */
    C_STRUCT aiVertexWeight *mWeights;

    /*------------------------------------------------------------------------------------------------
    이 행렬은 스켈레톤이 바인딩 되었을때 이 본의 로컬공간에서 메시의 위치를 알수있다.
     */
    C_STRUCT aiMatrix4x4 mOffsetMatrix;
}

+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=aiNode+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=

/*
계층 구조의 노드, 각 노드에는 이름, 상위노드(루트 노드제외), 상위 노드에 상대적인 변환 및 여러개의 하위 노드가 있다.
단순 파일 포맷은 계층구조를 지원하지 않는다. 이런한 포맷의 경우 가져온 장면은 자식없이 단일 루트 노드로만 구성된다.
*/
struct ASSIMP_API aiNode {
    /*
    노드의 이름, 이름은 비어있을 수 있지만 본에 의해 참조되는 노드는 제외된다.
    본에 의해 참조되는 노드를 제외하고는 여러 노드가 같은 이름을 가질 수 있다.
    카메라와 라이느틑 특정 노드를 이름으로 참조한다. 이 이름을 가진 노드가 여러개 있으면 각 노드에 할당된다.
    */
    C_STRUCT aiString mName;

    /*
    노드의 부모를 기준으로한 변환
    */
    C_STRUCT aiMatrix4x4 mTransformation;

    /*
    부모의 노드, 이 노드가 루트노드인 경우 nullptr
    */
    C_STRUCT aiNode* mParent;

    /*
    이 노드의 자식 노드의 수
    */
    unsigned int mNumChildren;

    /*
    이 노드의 자식 노드, mNumChilderen만큼의 자식을 갖는다., mNumChildren이 0이면 nullptr
    */
    C_STRUCT aiNode** mChildren;

    /*
    이 노드의 메시 수
    */
    unsigned int mNumMeshes;

    /*
    이 노드의 매시, 각 항목은 #aiScene의 메시 목록에 대한 인덱스
    */
    unsigned int* mMeshes;

    /*
    이 노드와 연결된 메타데이터가 없는 경우 nullptr이다.  
    */
    C_STRUCT aiMetadata* mMetaData;

    ///////////////////////////////폭죽//////////////////////////////////
    		//tempObject1->SetNextAnimation("Character@Cast Spell 02.FBX");
			CSParticleData temp;
			temp.position = tempVec;
			temp.position = {0, 20.f, 0};
			temp.playTime = 0;

			temp.color = { 0,1,0 };
			temp.lifeTime = 2;

			temp.direction = { 0,0,0 };
			temp.velocity = 20.0f;

			temp.Rotation = {0, 0, 0};
			temp.opacity = 1;

			temp.Scale = { 1,1,1 };
			temp.deltaOpacity = 0;

			temp.deltaRotation = { 0 ,0, 0 };
			temp.ScleRandomFactor = 0;

			temp.deltaScale = { -0.5f, -0.5f, -0.5f };

			temp.PosRandomFactor = { 0, 0, 0 };
			temp.RotRandomFactor = { 0, 0, 0 };
			temp.dirRandomFactor = { 1, 1, 1 };

			temp.deltaColor = { 0, 0, 0 };

			temp.gravity = 0;
			temp.colorRandomFactor = { 0, 0, 0 };

			m_pDearsGraphicsEngine->m_pParticleManager->AddParticle(200, temp);
///////////////////////////////////////////////////////////////////////////////